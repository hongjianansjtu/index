\section{Building Blocks}
\subsection{Attribute-Based Anonymous Credential}
Attribute-based anonymous credential system (ABACS) allows the issuance to users credentials that certify users' possession of an attribute. It is a useful primitive for service providers to implement fine-grained access control. Also, users could choose to selectively disclose part of its attributes to get authenticated. ABACS relies on attribute-based signature scheme. Our works relies on BBS+ signature scheme proposed by [], with a few modifications. The scheme works in a bilinear group $(\mathbb{G}_{1}, \mathbb{G}_{2}, \mathbb{G}_{T})$, with a bilinear map $e: \mathbb{G}_{1} \times \mathbb{G}_{2} \longrightarrow \mathbb{G}_{T}$. 
The constructed ABAC system could be described by the set of algorithms below:\\

\begin{enumerate}
    \item{\bf{Cred.Setup($1^\lambda$)$\rightarrow$($params$): }}Run by the credential issuer (authority, or identity provider) to define system parameters $params$. Choose a bilinear group $(\mathbb{G}_{1}, \mathbb{G}_{2}, \mathbb{G}_{T})$ with prime order $p$ and a pairing operation $e: \mathbb{G}_{1} \times \mathbb{G}_{2} \longrightarrow \mathbb{G}_{T}$. Let $g_1$ and $g_2$ be generators for $\mathbb{G}_{1}$ and $\mathbb{G}_{2}$ respectively. Define a credential schema $\mathcal{S}$ with attribute dimension $n$. The schema specifies the meaning of each attribute, and the $t$-th attribute is kept for the user's mobile number (MSISDN). Select randomly $n+2$ numbers $(h_p, h_0, h_1, ..., h_n)\in\mathbb{G}_{1}^{n+2}$. The system parameters are:$$params=(p, \mathbb{G}_{1}, \mathbb{G}_{2}, \mathbb{G}_{T}, e, g_1, g_2, h_p, h_0, h_1, ..., h_n).$$\\
    
    \item{\bf{Cred.KeyGen($params$)$\rightarrow$($sk, pk$): }}Run by the issuer to generate its own secret/public key pair. Randomly select $sk=\gamma\in\mathbb{Z}_{p}^{*}$. Parse system parameters, calculate and publish: 
    $$pp=(params, pk)=(params, g_2^{\gamma}).$$ \\
    
    \item{\bf{Cred.Issue($pp, sk, \mathcal{M}$)$\rightarrow$($\sigma$): }}Interactive protocol run between the user and the authority; The authority randomly picks $(x, s)\in\mathbb{Z}_{p} \times \mathbb{Z}_{p}$ and $s$ will be used as the linked secret in the generation of the virtual phone number $pm$. The user obtains a credential $\sigma$ embedding the set of public attributes $\mathcal{M}=\{M_i\}_{i\in[[1, n]]}$ and $(x, s)$. The attributes $\{M_i\}_{i\in[[1, n]]}$ are converted to $\{m_i\}_{i\in[[1, n]]}\in\mathbb{Z}_p^n$. The credential is sent to user through secret channel:
    $$\sigma = (A, x, s)=(\left(g_{1} \cdot h_{0}^{s} \cdot \prod_{i=1}^{n} h_{i}^{m_{i}}\right)^{\gamma+x}, x, s).$$\\
    
    \item{\bf{Cred.Prove1($RID, m_t, s$)$\rightarrow$($\Theta_1$): }}Run by the user to construct a proof $\Theta_1$ proving that it knows the real mobile phone number $m_t$ and the secret parameter $s$, and that the virtual number $pm$ is generated based on $(RID, m_t, s)$.\\
    
    \item{\bf{Cred.Verify1($RID, m_t, pm, \Theta_1$)$\rightarrow$($b$): }}Run by a third party verifier (the 5G system network) to verify based on $\Theta_1$ that $pm$ is generated by the user (user knows the secret parameters for $pm$'s generation).\\
    
    \item{\bf{Cred.Prove2($\sigma, RID, \mathcal{M}_h, \mathcal{M}_d, \Phi'$)$\rightarrow$($\mathcal{M}_d, \Theta_2, \Phi'$): }}Run by the user to construct a proof $\Theta_2$ proving: a) its possession of a credential $\sigma$ embedding the attributes $\mathcal{M}_d$ (disclosed) and $\mathcal{M}_h$ (hidden); b) the disclosed attributes $\mathcal{M}_d$ satisfy the statement $\Phi'$; c) $pm$ is generated based on $(RID, m_t, s)$.\\
    
    \item{\bf{Cred.Verify2($RID, m_t, pm, \Theta_1, \Phi_1$)$\rightarrow$($b$): }}Run by a third party verifier (the service provider, also referred to as the relying party) to verify that the material presented by $\Theta_1$ satisfies the statement $\Phi_1$.

\end{enumerate}
\subsection{Generation of Virtual Mobile Phone Number}
As is previously mentioned, the generation of the virtual mobile phone number is based on on $(RID, m_t, s)$, where RID is a unique identifier assigned to the service provider, $m_t$ is the mobile phone number of the user (MSISDN), and $s$ is the linked secret that user obtains in the issuance of the attribute-based anonymous credential. We design the algorithm for the generation of the virtual number $pm$ as 
$pm\leftarrow \bf{PMGen(}$$RID, m_t, s$$\bf{)}$:
$$\bf{PMGen(}\mathit{RID, m_t, s}\bf{)}=\mathit{H_1(RID)^{m_t}}\cdot\mathit{H_2(RID)^{s}}.$$\\
By employing zero-knowledge proof, it is impossible for user to pass the authentication with a third-party service provider if the virtual number submitted is not generated from $(RID, m_t, s)$. Based on one credential, a user couldn't generate more than one virtual numbers for the authentication with the same service provider.

\subsection{Zero Proof of Knowledge}
Zero-knowledge proof is a  cryptographic method used for proving that a given statement is true without revealing any additional information . A zero-knowledge proof system involves two entities: the prover and the verifer. The prover is interested in convincing the verifer its knowledge of a secret value without revealing any information about it. Further more, prover may also convince the verifier its knowledge of a secret value satisfying certain statements, also known as the ZKP predicate. As a trade-off for migration from CL signature to BBS+, existing BBS+ Signature implementations do not support ZKP proof predicates. 
In our scheme, non-interactive zero-knowledge proof (NIZKP) is employed in the registration of the virtual number at the 5G system network to prove user's knowledge of , and 


\subsection{5G SMS-Relay Service}
The combination of the anonymous credential system with the second authentication factor is based on the SMS-relay service provided by the 5G system network. In our multi-factor authentication scheme, a user who wants to access resources provided by a third party service provider has to send the materials for verification (a proof constructed by the user based on the anonymous credential) together with the virtual mobile phone number to the service provider. Once the validity of the material is verified, the service provider will require user to fill in a verification code. This is where the SMS-relay service comes in. Since the phone number submitted by the user is only a virtual one, it is the 5G network that takes charge of the routing to the target user. The unified data management (UDM) maintains a database storing the mapping relationship from the virtual mobile number to the real one. When the service provider sends an SMS (verification code) to the virtual number, the UDM is queried. Then the message could be relayed through the 5g network to the user's mobile phone based on its real phone number and other routing information stored in UDM.

If the user hadn't registered the virtual number at 5G network, the relay of verification code couldn't succeed. The registration of the the virtual number, as has been introduced previously in $\bf{Cred.Prove1}$, involves constructing a zero-knowledge proof which proves that the user knows the link secret $s$ based on which the virtual number $pm$ is generated. Without possession of an anonymous credential, the user could still accomplish registration of an invalid virtual number by replacing the link secret with a random number. However, the invalid virtual number won't be able to pass the third party service provider's verification in the first step of verification, and would be useless.

To register for a virtual phone number $pm$, the user sends $pm$ and the correlated ZKP information to the access and mobility management function (AMF), which then transmits $pm$ and ZKP proof to the unified data management (UDM). UDM checks the validity of ZKP proof and either accepts or rejects the registration.


